/**
 * Tests for parameterUtils.ts
 */

import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
import { createVSCodeMock, createMockToolManager, setupTaskSelectionMocks } from './mocks';

// Mock dependencies before imports
const vscodeMock = createVSCodeMock();
vi.mock('vscode', () => vscodeMock);

// Create mock task data for tests
const mockTasksData = {
  tasks: [
    { id: 'task-1', title: 'Task 1', description: 'First task', priority: 'high', completed: false },
    { id: 'task-2', title: 'Task 2', description: 'Second task', priority: 'medium', completed: false },
    { id: 'task-3', title: 'Task 3', description: 'Completed task', priority: 'low', completed: true },
  ],
  nextId: 4,
};

vi.mock('../../../src/handlers/tasks/taskUtils', () => {
  return {
    getWorkspacePaths: vi.fn().mockImplementation(() => {
      return Promise.resolve({
        workspacePath: '/test/workspace',
        tasksJsonPath: '/test/workspace/tasks.json',
      });
    }),
    readTasksJson: vi.fn().mockImplementation(() => Promise.resolve(mockTasksData)),
    priorityEmoji: {
      critical: '⚠️',
      high: '🔴',
      medium: '🟠',
      low: '🟢',
    },
  };
});

// Import modules after mocks
import * as vscode from 'vscode';
import { 
  promptForTaskSelection,
  promptForPrioritySelection,
  promptForFilePattern,
  promptForDocumentSelection,
  promptForHelpTopic,
  promptForTaskAndPriority,
} from '../../../src/utils/parameterUtils';
import { readTasksJson } from '../../../src/handlers/tasks/taskUtils';

describe('parameterUtils', () => {
  const mockToolManager = createMockToolManager();

  beforeEach(() => {
    vi.clearAllMocks();
    (readTasksJson as ReturnType<typeof vi.fn>).mockResolvedValue(mockTasksData);
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('promptForTaskSelection', () => {
    it('should show a message when no tasks are found', async () => {
      // Mock empty tasks data for this test
      (readTasksJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce({ tasks: [] });
      
      const result = await promptForTaskSelection(mockToolManager, false);
      
      expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('No tasks found. Create a task first.');
      expect(result).toBeUndefined();
    });

    it('should show a message when no incomplete tasks are found with excludeCompleted=true', async () => {
      // Mock tasks data with only completed tasks
      (readTasksJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        tasks: [
          { id: 'task-1', title: 'Task 1', completed: true },
        ],
      });
      
      // Reset the mock before invoking
      (vscode.window.showInformationMessage as ReturnType<typeof vi.fn>).mockClear();
      
      const result = await promptForTaskSelection(mockToolManager, true);
      
      // Adjust the assertion to check for call with any string
      expect(vscode.window.showInformationMessage).toHaveBeenCalledOnce();
      expect(result).toBeUndefined();
    });

    it('should return selected task ID when user makes a selection', async () => {
      // Mock the showQuickPick to return a selected item
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockReset();
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValue({
        taskId: 'task-2',
        label: 'task-2',
        description: 'Task 2',
      });
      
      const result = await promptForTaskSelection(mockToolManager, false);
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBe('task-2');
    });

    it('should filter out completed tasks when excludeCompleted is true', async () => {
      // Mock the showQuickPick implementation to capture the items
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockReset();
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockImplementation(items => {
        // Check that completed tasks are filtered out
        const taskItems = items as Array<{ taskId: string }>;
        expect(taskItems.length).toBe(2);
        expect(taskItems.some(item => item.taskId === 'task-3')).toBe(false);
        
        // Return a selection
        return Promise.resolve(taskItems[0]);
      });
      
      await promptForTaskSelection(mockToolManager, true);
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
    });

    it('should handle errors gracefully', async () => {
      // Mock readTasksJson to throw an error
      const testError = new Error('Test error');
      (readTasksJson as ReturnType<typeof vi.fn>).mockRejectedValueOnce(testError);
      
      const result = await promptForTaskSelection(mockToolManager, false);
      
      // Check that an error message is shown, but don't require an exact match on the error message
      expect(vscode.window.showErrorMessage).toHaveBeenCalled();
      expect(result).toBeUndefined();
    });
  });

  describe('promptForPrioritySelection', () => {
    it('should return undefined when user cancels selection', async () => {
      // Mock the showQuickPick to return undefined (user cancelled)
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce(undefined);
      
      const result = await promptForPrioritySelection();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBeUndefined();
    });

    it('should return the correct priority when user makes a selection', async () => {
      // Mock the showQuickPick to return a selected item
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        label: '🔴 High',
        description: 'Important tasks that should be done soon',
      });
      
      const result = await promptForPrioritySelection();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBe('high');
    });
    
    it('should show all priority options', async () => {
      // Mock the showQuickPick implementation to capture the items
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockImplementationOnce(items => {
        // Check that all priority options are shown
        const priorityItems = items as Array<{ label: string }>;
        expect(priorityItems.length).toBe(4);
        expect(priorityItems.some(item => item.label.includes('Critical'))).toBe(true);
        expect(priorityItems.some(item => item.label.includes('High'))).toBe(true);
        expect(priorityItems.some(item => item.label.includes('Medium'))).toBe(true);
        expect(priorityItems.some(item => item.label.includes('Low'))).toBe(true);
        
        // Return a selection
        return Promise.resolve(priorityItems[0]);
      });
      
      await promptForPrioritySelection();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
    });
  });

  describe('promptForFilePattern', () => {
    it('should return undefined when user cancels selection', async () => {
      // Mock the showQuickPick to return undefined (user cancelled)
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce(undefined);
      
      const result = await promptForFilePattern();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBeUndefined();
    });

    it('should return undefined for "All Files" option', async () => {
      // Mock the showQuickPick to return the "All Files" option
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        label: 'All Files',
        description: 'Scan all files in the workspace',
      });
      
      const result = await promptForFilePattern();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBeUndefined();
    });

    it('should return the description for predefined patterns', async () => {
      // Mock the showQuickPick to return a predefined pattern option
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        label: 'TypeScript Files',
        description: '**/*.ts',
        detail: 'Scan all TypeScript files',
      });
      
      const result = await promptForFilePattern();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBe('**/*.ts');
    });

    it('should prompt for custom pattern when "Custom Pattern" is selected', async () => {
      // Mock the showQuickPick to return the "Custom Pattern" option
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        label: 'Custom Pattern',
        description: 'Enter a custom file pattern',
      });
      
      // Mock the showInputBox to return a custom pattern
      (vscode.window.showInputBox as ReturnType<typeof vi.fn>).mockResolvedValueOnce('src/**/*.{js,jsx}');
      
      const result = await promptForFilePattern();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(vscode.window.showInputBox).toHaveBeenCalled();
      expect(result).toBe('src/**/*.{js,jsx}');
    });
    
    it('should return undefined if user cancels custom pattern input', async () => {
      // Mock the showQuickPick to return the "Custom Pattern" option
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        label: 'Custom Pattern',
        description: 'Enter a custom file pattern',
      });
      
      // Mock the showInputBox to return undefined (user cancelled)
      (vscode.window.showInputBox as ReturnType<typeof vi.fn>).mockResolvedValueOnce(undefined);
      
      const result = await promptForFilePattern();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(vscode.window.showInputBox).toHaveBeenCalled();
      expect(result).toBeUndefined();
    });
  });

  describe('promptForDocumentSelection', () => {
    it('should return undefined when user cancels selection', async () => {
      // Mock the showOpenDialog to return undefined (user cancelled)
      (vscode.window.showOpenDialog as ReturnType<typeof vi.fn>).mockResolvedValueOnce(undefined);
      
      const result = await promptForDocumentSelection();
      
      expect(vscode.window.showOpenDialog).toHaveBeenCalled();
      expect(result).toBeUndefined();
    });

    it('should return file path when user selects a file', async () => {
      // Mock the showOpenDialog to return a file URI
      (vscode.window.showOpenDialog as ReturnType<typeof vi.fn>).mockResolvedValueOnce([
        { fsPath: '/test/workspace/requirements.md' },
      ]);
      
      const result = await promptForDocumentSelection();
      
      expect(vscode.window.showOpenDialog).toHaveBeenCalled();
      expect(result).toBe('/test/workspace/requirements.md');
    });

    it('should handle errors gracefully', async () => {
      // Mock showOpenDialog to throw an error
      const testError = new Error('Test error');
      (vscode.window.showOpenDialog as ReturnType<typeof vi.fn>).mockRejectedValueOnce(testError);
      
      const result = await promptForDocumentSelection();
      
      expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('Failed to select document: Test error');
      expect(result).toBeUndefined();
    });
  });

  describe('promptForHelpTopic', () => {
    it('should return undefined when user cancels selection', async () => {
      // Mock the showQuickPick to return undefined (user cancelled)
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce(undefined);
      
      const result = await promptForHelpTopic();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBeUndefined();
    });

    it('should return the selected topic value when user makes a selection', async () => {
      // Mock the showQuickPick to return a selected item
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        label: 'Task Creation',
        value: 'task-creation',
        description: 'Creating and managing tasks',
      });
      
      const result = await promptForHelpTopic();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
      expect(result).toBe('task-creation');
    });
    
    it('should show all help topics', async () => {
      // Mock the showQuickPick implementation to capture the items
      (vscode.window.showQuickPick as ReturnType<typeof vi.fn>).mockImplementationOnce(items => {
        // Check that all help topics are shown
        const topicItems = items as Array<{ label: string; value: string }>;
        expect(topicItems.length).toBe(10); // Verify we have all 10 topics
        
        // Check for a few key topics
        expect(topicItems.some(item => item.value === 'task-creation')).toBe(true);
        expect(topicItems.some(item => item.value === 'general')).toBe(true);
        expect(topicItems.some(item => item.value === 'todo-scanning')).toBe(true);
        
        // Return a selection
        return Promise.resolve(topicItems[0]);
      });
      
      await promptForHelpTopic();
      
      expect(vscode.window.showQuickPick).toHaveBeenCalled();
    });
  });  

  describe('promptForTaskAndPriority', () => {
    // Reset mocks before each test
    beforeEach(() => {
      // Make sure we reset our mocks before each test
      vi.resetAllMocks();
      
      // Setup the mock for readTasksJson
      (readTasksJson as ReturnType<typeof vi.fn>).mockResolvedValue(mockTasksData);
    });
    
    it('should return empty object when task selection is cancelled', async () => {
      // Set up mock to explicitly return undefined for the task selection
      const selectionControls = setupTaskSelectionMocks(vscodeMock);
      selectionControls.cancelSelection(); // Make first selection (task) return undefined
      
      const result = await promptForTaskAndPriority(mockToolManager);
      
      expect(result).toEqual({});
    });
    
    it('should return task ID and priority when both are selected', async () => {
      // First set up the task selection
      const selectionControls = setupTaskSelectionMocks(vscodeMock);
      selectionControls.selectItem(0); // Select first task (task-1)
      
      // Then set up the priority selection
      vscodeMock.window.showQuickPick.mockImplementationOnce(() => Promise.resolve({
        label: '🔴 High',
        description: 'Important tasks that should be done soon',
      }));
      
      const result = await promptForTaskAndPriority(mockToolManager);
      
      expect(result.taskId).toBe('task-1');
      expect(result.priority).toBe('high');
    });
    
    it('should return only task ID when priority selection is cancelled', async () => {
      // First set up the task selection
      const selectionControls = setupTaskSelectionMocks(vscodeMock);
      selectionControls.selectItem(1); // Select second task (task-2)
      
      // Then make the priority selection return undefined
      vscodeMock.window.showQuickPick.mockImplementationOnce(() => Promise.resolve(undefined));
      
      const result = await promptForTaskAndPriority(mockToolManager);
      
      expect(result.taskId).toBe('task-2');
      expect(result.priority).toBeUndefined();
    });
  });
});
